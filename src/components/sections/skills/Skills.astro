---
// Skills.astro - A constellation skills display
import { Icon } from "astro-icon/components";

// Group skills by category for visualization
const skillGroups = [
  {
    category: "Languages",
    color: "oklch(var(--accent-300))",
    skills: [
      { name: "JavaScript", icon: "simple-icons:javascript" },
      { name: "HTML", icon: "simple-icons:html5" },
      { name: "CSS", icon: "simple-icons:css3" },
      { name: "TypeScript", icon: "simple-icons:typescript" },
      { name: "Python", icon: "simple-icons:python" },
      { name: "C/C++", icon: "simple-icons:cplusplus" },
      { name: "Java", icon: "simple-icons:coffeescript" },
      { name: "PHP", icon: "simple-icons:php" },
      { name: "SQL", icon: "simple-icons:postgresql" },
    ],
  },
  {
    category: "Frameworks & Libraries",
    color: "oklch(var(--accent-500))",
    skills: [
      { name: "React", icon: "simple-icons:react" },
      { name: "NextJS", icon: "simple-icons:nextdotjs" },
      { name: "Svelte", icon: "simple-icons:svelte" },
      { name: "Redux", icon: "simple-icons:redux" },
      { name: "TailwindCSS", icon: "simple-icons:tailwindcss" },
      { name: "Astro", icon: "simple-icons:astro" },
      { name: "Django", icon: "simple-icons:django" },
      { name: "Firebase", icon: "simple-icons:firebase" },
    ],
  },
  {
    category: "Tools & Environments",
    color: "oklch(var(--accent-900))",
    skills: [
      { name: "Git", icon: "simple-icons:git" },
      { name: "GitHub", icon: "simple-icons:github" },
      { name: "Linux", icon: "simple-icons:linux" },
      { name: "Bash", icon: "simple-icons:gnubash" },
      { name: "Batch", icon: "simple-icons:windowsterminal" },
      { name: "Vim", icon: "simple-icons:vim" },
      { name: "Figma", icon: "simple-icons:figma" },
      { name: "LaTeX", icon: "simple-icons:latex" },
      { name: "Markdown", icon: "simple-icons:markdown" },
      { name: "GitHub Actions", icon: "simple-icons:githubactions" },
      { name: "Jira", icon: "simple-icons:jira" },
      { name: "Scrum", icon: "simple-icons:scrumalliance" },
      { name: "Googling", icon: "simple-icons:google" },
    ],
  },
];

// Flatten all skills for rendering
const allSkills = skillGroups.flatMap((group) => group.skills.map((skill) => ({ ...skill, category: group.category, color: group.color })));
---

<section id="skills" class="py-24 relative overflow-hidden">
  <!-- Accent elements in background -->
  <div class="absolute inset-0 pointer-events-none">
    <div class="hero-ring w-[120%] aspect-square opacity-10"></div>
    <div class="hero-ring w-[80%] aspect-square opacity-5"></div>
  </div>

  <div class="container mx-auto px-4 relative z-10">
    <div class="text-center mb-16">
      <h2 class="text-4xl md:text-5xl font-bold mb-3 inline-block bg-gradient-to-r from-[oklch(var(--accent-300))] to-[oklch(var(--accent-500))] text-transparent bg-clip-text">Technical <span class="font-doto font-bold"> Skills</span></h2>
      <div class="w-24 h-1 bg-gradient-to-r from-[oklch(var(--accent-500))] to-[oklch(var(--accent-900))] mx-auto rounded-full"></div>
      <p class="text-foreground-muted max-w-2xl mx-auto mt-6 text-lg">A collection of technologies I've worked with</p>
    </div>

    <!-- Legend/filter for constellation -->
    <div class="flex flex-wrap justify-center gap-4 mb-10">
      {
        skillGroups.map((group) => (
          <button class="skill-filter px-4 py-2 rounded-full border text-sm transition-all duration-300 hover:scale-105" data-category={group.category} style={`--filter-color: ${group.color}`}>
            {group.category}
          </button>
        ))
      }
      <button class="skill-filter px-4 py-2 rounded-full border text-sm transition-all duration-300 hover:scale-105 active" data-category="all"> All Skills </button>
    </div>

    <!-- Skill constellation -->
    <div class="skill-constellation relative h-[600px] mx-auto">
      {
        allSkills.map((skill, index) => (
          <div class="skill-node" data-category={skill.category} style={`--delay: ${index * 0.05}s; --color: ${skill.color}`}>
            <div class="skill-bubble">
              <div class="skill-icon">
                <Icon name={skill.icon} />
              </div>
              <div class="skill-name">{skill.name}</div>
            </div>
          </div>
        ))
      }
    </div>
  </div>
</section>

<style>
  .skill-constellation {
    perspective: 1000px;
    max-width: 1000px;
    position: relative;
  }

  .skill-node {
    position: absolute;
    opacity: 0;
    transform: scale(0);
  }

  .skill-node.visible {
    opacity: 1;
    transform: scale(1);
    transition: all 0.5s cubic-bezier(0.175, 0.885, 0.32, 1.275);
    transition-delay: var(--delay);
  }

  .skill-bubble {
    width: 85px;
    height: 85px;
    border-radius: 50%;
    background: rgba(var(--background), 0.7);
    backdrop-filter: blur(5px);
    border: 2px solid rgba(255, 255, 255, 0.05);
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    box-shadow: 0 4px 15px -5px rgba(0, 0, 0, 0.5);
    transition: all 0.3s cubic-bezier(0.175, 0.885, 0.32, 1.275);
    padding: 10px;
    position: relative;
    overflow: hidden;
  }

  /* Glow effect based on category */
  .skill-bubble::before {
    content: "";
    position: absolute;
    top: 0;
    left: 0;
    right: 0;
    bottom: 0;
    background: radial-gradient(circle at center, var(--color) 0%, transparent 70%);
    opacity: 0;
    transition: opacity 0.3s ease;
    z-index: -1;
  }

  .skill-icon {
    font-size: 1.8rem;
    margin-bottom: 5px;
    color: var(--color, oklch(var(--accent-text)));
    transition: transform 0.3s ease;
  }

  .skill-name {
    font-size: 0.7rem;
    font-weight: 500;
    line-height: 1.1;
    text-align: center;
    transition: opacity 0.3s ease;
    opacity: 0.8;
  }

  /* Hover effects */
  .skill-bubble:hover {
    border-color: var(--color);
    transform: translateY(-5px);
    box-shadow: 0 10px 25px -5px rgba(0, 0, 0, 0.5);
  }

  .skill-bubble:hover::before {
    opacity: 0.15;
  }

  .skill-bubble:hover .skill-icon {
    transform: translateY(-2px);
  }

  .skill-bubble:hover .skill-name {
    opacity: 1;
  }

  /* Connection lines between related skills */
  .skill-connection {
    position: absolute;
    background: linear-gradient(90deg, transparent, var(--connection-color, rgba(255, 255, 255, 0.1)), transparent);
    height: 1px;
    transform-origin: left center;
    opacity: 0;
    transition: opacity 0.5s ease;
    pointer-events: none;
    z-index: -1;
  }

  .skill-connection.visible {
    opacity: 0.15;
  }

  /* Filter buttons */
  .skill-filter {
    background-color: rgba(var(--background), 0.5);
    border-color: rgba(255, 255, 255, 0.1);
    color: rgb(var(--foreground-muted));
    transition: all 0.3s ease;
  }

  .skill-filter:hover {
    border-color: var(--filter-color, oklch(var(--accent-500)));
    color: rgb(var(--foreground));
  }

  .skill-filter.active {
    background-color: var(--filter-color, oklch(var(--accent-500)));
    border-color: var(--filter-color, oklch(var(--accent-500)));
    color: rgb(var(--background));
  }

  /* Responsive adjustments */
  @media (max-width: 768px) {
    .skill-constellation {
      height: 900px;
    }

    .skill-bubble {
      width: 75px;
      height: 75px;
    }
  }
</style>

<script>
  document.addEventListener("DOMContentLoaded", () => {
    const constellation = document.querySelector(".skill-constellation");
    const nodes = Array.from(document.querySelectorAll(".skill-node"));
    const filterButtons = document.querySelectorAll(".skill-filter");
    let connections = [];

    // Initialize positions
    function initializePositions() {
      // Calculate a dynamic layout based on screen size
      const containerWidth = constellation.clientWidth;
      const containerHeight = constellation.clientHeight;
      const centerX = containerWidth / 2;
      const centerY = containerHeight / 2;

      // Position nodes in a structured but organic pattern
      nodes.forEach((node, index) => {
        // Use golden ratio for distribution
        const phi = (1 + Math.sqrt(5)) / 2;
        const i = index + 1;

        // Calculate radius and angle for a spiral-like pattern
        const radius = Math.sqrt(i) * 30;
        const angle = i * phi * Math.PI * 2;

        // Convert to cartesian coordinates with some randomness
        const randomOffset = Math.random() * 40 - 20;
        const x = centerX + Math.cos(angle) * (radius + randomOffset);
        const y = centerY + Math.sin(angle) * (radius + randomOffset);

        // Apply position
        node.style.left = `${Math.max(0, Math.min(containerWidth - 85, x))}px`;
        node.style.top = `${Math.max(0, Math.min(containerHeight - 85, y))}px`;
      });
    }

    // Create connections between related skills
    function createConnections() {
      // Remove existing connections
      document.querySelectorAll(".skill-connection").forEach((conn) => conn.remove());
      connections = [];

      // Only create connections for visible nodes
      const visibleNodes = nodes.filter((node) => node.classList.contains("visible"));

      // Group nodes by category
      const categories = {};
      visibleNodes.forEach((node) => {
        const category = node.dataset.category;
        if (!categories[category]) categories[category] = [];
        categories[category].push(node);
      });

      // Create connections within each category
      Object.entries(categories).forEach(([category, categoryNodes]) => {
        // Get color from the first node in category
        const color = categoryNodes[0].style.getPropertyValue("--color");

        categoryNodes.forEach((node, i) => {
          // Connect to a few nearby nodes in same category
          for (let j = i + 1; j < Math.min(i + 3, categoryNodes.length); j++) {
            if (Math.random() > 0.3) {
              // 70% chance to create connection
              const nodeRect = node.getBoundingClientRect();
              const targetRect = categoryNodes[j].getBoundingClientRect();
              const constellationRect = constellation.getBoundingClientRect();

              // Calculate positions relative to constellation
              const x1 = nodeRect.left + nodeRect.width / 2 - constellationRect.left;
              const y1 = nodeRect.top + nodeRect.height / 2 - constellationRect.top;
              const x2 = targetRect.left + targetRect.width / 2 - constellationRect.left;
              const y2 = targetRect.top + targetRect.height / 2 - constellationRect.top;

              // Calculate distance and angle
              const dx = x2 - x1;
              const dy = y2 - y1;
              const distance = Math.sqrt(dx * dx + dy * dy);
              const angle = (Math.atan2(dy, dx) * 180) / Math.PI;

              // Create connection element
              const connection = document.createElement("div");
              connection.className = "skill-connection";
              connection.style.width = `${distance}px`;
              connection.style.left = `${x1}px`;
              connection.style.top = `${y1}px`;
              connection.style.transform = `rotate(${angle}deg)`;
              connection.style.setProperty("--connection-color", color);

              // Add to DOM and track
              constellation.appendChild(connection);
              connections.push(connection);

              // Animate in
              setTimeout(() => {
                connection.classList.add("visible");
              }, 50);
            }
          }
        });
      });
    }

    // Initialize filter functionality
    function initializeFilters() {
      filterButtons.forEach((button) => {
        button.addEventListener("click", () => {
          // Update active state
          filterButtons.forEach((btn) => btn.classList.remove("active"));
          button.classList.add("active");

          const category = button.dataset.category;

          // Hide all nodes first
          nodes.forEach((node) => {
            node.classList.remove("visible");
          });

          // Show nodes that match the filter
          setTimeout(() => {
            nodes.forEach((node) => {
              if (category === "all" || node.dataset.category === category) {
                node.classList.add("visible");
              }
            });

            // Update connections after nodes are visible
            setTimeout(createConnections, 100);
          }, 300);
        });
      });
    }

    // Make nodes interactive
    function initializeNodeInteraction() {
      nodes.forEach((node) => {
        node.addEventListener("mouseenter", () => {
          const category = node.dataset.category;

          // Highlight connections for this node
          connections.forEach((conn) => {
            conn.style.opacity = "0.05";
          });

          // Highlight nodes in same category
          nodes.forEach((otherNode) => {
            if (otherNode.dataset.category === category) {
              otherNode.querySelector(".skill-bubble").style.borderColor = otherNode.style.getPropertyValue("--color");
            } else {
              otherNode.style.opacity = "0.5";
            }
          });

          node.style.opacity = "1";
          node.style.zIndex = "10";
        });

        node.addEventListener("mouseleave", () => {
          // Reset node styles
          nodes.forEach((otherNode) => {
            otherNode.style.opacity = "1";
            otherNode.style.zIndex = "auto";
            otherNode.querySelector(".skill-bubble").style.borderColor = "";
          });

          // Reset connection styles
          connections.forEach((conn) => {
            conn.style.opacity = "";
          });
        });
      });
    }

    // Initial setup
    function initialize() {
      initializePositions();

      // Show all nodes with animation delay
      setTimeout(() => {
        nodes.forEach((node) => node.classList.add("visible"));

        // Create connections after nodes are visible
        setTimeout(createConnections, 500);
      }, 300);

      initializeFilters();
      initializeNodeInteraction();
    }

    // Handle window resize
    let resizeTimeout;
    window.addEventListener("resize", () => {
      clearTimeout(resizeTimeout);
      resizeTimeout = setTimeout(() => {
        initializePositions();
        createConnections();
      }, 250);
    });

    initialize();
  });
</script>
