---
import { Icon } from "astro-icon/components";
import TechPill from "./TechPill.astro";
import "./project-showcase.css";

export interface Project {
  title: string;
  shortDescription: string;
  imageUrls: string[];
  techStack: string[];
  liveUrl?: string;
  repoUrl?: string;
  imageLayout?: "cover" | "contain";
  backgroundStyle?: string;
  layout?: string;
}

const projects: Project[] = [
  {
    title: "Portfolio Site V3",
    shortDescription: "This portfolio, built with Astro, showcasing interactive components and design.",
    imageUrls: [
      "https://images.unsplash.com/photo-1517694712202-14dd9538aa97?ixlib=rb-4.0.3&ixid=M3wxMjA3fDB8MHxwaG90by1wYWdlfHx8fGVufDB8fHx8fA%3D%3D&auto=format&fit=crop&w=1170&q=80",
      "https://images.unsplash.com/photo-1555949963-ff9fe0c870eb?ixlib=rb-4.0.3&ixid=M3wxMjA3fDB8MHxwaG90by1wYWdlfHx8fGVufDB8fHx8fA%3D%3D&auto=format&fit=crop&w=1170&q=80",
      "https://images.unsplash.com/photo-1587620962725-abab7fe55159?ixlib=rb-4.0.3&ixid=M3wxMjA3fDB8MHxwaG90by1wYWdlfHx8fGVufDB8fHx8fA%3D%3D&auto=format&fit=crop&w=1031&q=80",
    ],
    techStack: ["Astro", "TailwindCSS", "TypeScript", "Vercel"],
    liveUrl: "#",
    repoUrl: "https://github.com/yourusername/portfolio-v3",
    imageLayout: "cover",
  },
  {
    title: "E-Commerce Platform",
    shortDescription: "Full-featured online store with user auth, cart, and checkout.",
    imageUrls: [
      "https://images.unsplash.com/photo-1522204523234-8729aa6e3d5f?ixlib=rb-4.0.3&ixid=M3wxMjA3fDB8MHxwaG90by1wYWdlfHx8fGVufDB8fHx8fA%3D%3D&auto=format&fit=crop&w=1170&q=80",
      "https://images.unsplash.com/photo-1585194166760-6090e40f094e?ixlib=rb-4.0.3&ixid=M3wxMjA3fDB8MHxwaG90by1wYWdlfHx8fGVufDB8fHx8fA%3D%3D&auto=format&fit=crop&w=1170&q=80",
      "https://images.unsplash.com/photo-1563013544-824ae1b704d3?ixlib=rb-4.0.3&ixid=M3wxMjA3fDB8MHxwaG90by1wYWdlfHx8fGVufDB8fHx8fA%3D%3D&auto=format&fit=crop&w=1170&q=80",
    ],
    techStack: ["React", "Next.js", "Firebase", "Stripe API", "TailwindCSS"],
    liveUrl: "#",
    repoUrl: "#",
    imageLayout: "cover",
  },
  {
    title: "Data Visualizer",
    shortDescription: "Interactive dashboard displaying complex data using charts.",
    imageUrls: [
      "https://images.unsplash.com/photo-1551288049-bebda4e38f71?ixlib=rb-4.0.3&ixid=M3wxMjA3fDB8MHxwaG90by1wYWdlfHx8fGVufDB8fHx8fA%3D%3D&auto=format&fit=crop&w=1170&q=80",
      "https://images.unsplash.com/photo-1611162617474-5b21e879e113?ixlib=rb-4.0.3&ixid=M3wxMjA3fDB8MHxwaG90by1wYWdlfHx8fGVufDB8fHx8fA%3D%3D&auto=format&fit=crop&w=1074&q=80",
      "https://images.unsplash.com/photo-1460925895917-afdab827c52f?ixlib=rb-4.0.3&ixid=M3wxMjA3fDB8MHxwaG90by1wYWdlfHx8fGVufDB8fHx8fA%3D%3D&auto=format&fit=crop&w=1115&q=80",
    ],
    techStack: ["SvelteKit", "D3.js", "Python", "FastAPI"],
    liveUrl: "#",
    repoUrl: "#",
    imageLayout: "cover",
  },
];

function techNameToSlug(name: string): string {
  return name
    .toLowerCase()
    .replace(/\+/g, "plus")
    .replace(/[^a-z0-9]/g, "");
}
---

<section id="projects" class="py-20 md:py-28 scroll-mt-20">
  <div class="container mx-auto px-4">
    <div class="text-center mb-12 md:mb-16">
      <h2 class="text-4xl md:text-5xl font-bold mb-3 inline-block bg-gradient-to-r from-[oklch(var(--accent-300))] to-[oklch(var(--accent-500))] text-transparent bg-clip-text">
        My <span class="font-doto font-bold">Creations</span>
      </h2>
      <div class="w-24 h-1 bg-gradient-to-r from-[oklch(var(--accent-500))] to-[oklch(var(--accent-900))] mx-auto rounded-full"></div>
      <p class="text-foreground-muted max-w-2xl mx-auto mt-6 text-lg">A selection of projects where code meets creativity.</p>
    </div>

    <div id="project-grid-container" class="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-8 md:gap-10">
      {
        projects.map((project, index) => (
          <article class="project-card" data-aos="fade-up" data-aos-delay={index * 100}>
            <div class="slider-viewport">
              <div class="slider-container" data-total-slides={project.imageUrls.length}>
                {project.imageUrls.map((url, slideIndex) => (
                  <div class="slider-slide" data-slide-index={slideIndex}>
                    <img src={url} alt={`${project.title} screenshot ${slideIndex + 1}`} loading="lazy" width="800" height="500" />
                  </div>
                ))}
              </div>

              {project.imageUrls.length > 1 && (
                <>
                  <button type="button" aria-label="Previous Slide" class="slider-button prev" data-direction="-1">
                    <Icon name="mdi:chevron-left" />
                  </button>
                  <button type="button" aria-label="Next Slide" class="slider-button next" data-direction="1">
                    <Icon name="mdi:chevron-right" />
                  </button>

                  <div class="slider-pagination">
                    {project.imageUrls.map((_, i) => (
                      <button class={`pagination-dot ${i === 0 ? "active" : ""}`} data-index={i} aria-label={`Go to slide ${i + 1}`} title={`Slide ${i + 1}`} />
                    ))}
                  </div>

                  <div class="slide-counter">
                    <span class="current-slide">1</span>
                    <span class="total-slides">/{project.imageUrls.length}</span>
                  </div>
                </>
              )}

              <button type="button" class="fullscreen-button" aria-label="View image fullscreen">
                <Icon name="mdi:fullscreen" />
              </button>
            </div>

            <div class="project-info">
              <h3 class="project-title">{project.title}</h3>
              <p class="project-description">{project.shortDescription}</p>

              <div class="project-tech">
                <div class="flex flex-wrap gap-1.5">
                  {project.techStack.map((tech) => (
                    <TechPill name={tech} data-tech={techNameToSlug(tech)} />
                  ))}
                </div>
              </div>

              <div class="project-links">
                {project.liveUrl && (
                  <a href={project.liveUrl} target="_blank" rel="noopener noreferrer" class="project-link" title="View live demo">
                    <Icon name="mdi:open-in-new" />
                    <span>View Project</span>
                  </a>
                )}
                {project.repoUrl && (
                  <a href={project.repoUrl} target="_blank" rel="noopener noreferrer" class="project-link" title="View source code">
                    <Icon name="mdi:github" />
                    <span>Source Code</span>
                  </a>
                )}
              </div>
            </div>
          </article>
        ))
      }
    </div>
  </div>
</section>

<script>
  document.addEventListener("DOMContentLoaded", () => {
    // Store original scroll position and overflow value
    let originalScrollPos = 0;
    let originalOverflow = "";
    let bodyStyle = document.body.style;
    let isLightboxOpen = false;

    // Cached selectors
    const gridContainer = document.getElementById("project-grid-container");
    const cards = Array.from(document.querySelectorAll(".project-card"));
    const sliders = Array.from(document.querySelectorAll(".slider-container"));

    // Touch state objects by slider element (using WeakMap for memory optimization)
    const touchStates = new WeakMap();

    // --- Performance optimization for observation ----
    if ("IntersectionObserver" in window) {
      // Use a single observer for all cards to improve performance
      const cardObserver = new IntersectionObserver(
        (entries) => {
          entries.forEach((entry) => {
            if (entry.isIntersecting) {
              // Delay adding the class to stagger animations and improve rendering
              requestAnimationFrame(() => {
                entry.target.classList.add("is-visible");
              });
              cardObserver.unobserve(entry.target);
            }
          });
        },
        { threshold: 0.1, rootMargin: "0px 0px -100px 0px" }
      );

      // Observe each card with a small delay between observations
      cards.forEach((card, index) => {
        setTimeout(() => {
          cardObserver.observe(card);
        }, index * 50); // Stagger observation to improve performance
      });
    } else {
      // Fallback for browsers without IntersectionObserver
      cards.forEach((card) => card.classList.add("is-visible"));
    }

    // ----- Event Delegation for Better Performance -----
    if (gridContainer) {
      gridContainer.addEventListener(
        "click",
        (e) => {
          if (isLightboxOpen) return; // Prevent interactions when lightbox is open

          // Find the closest interactive element
          const target = e.target;
          const button = target.closest(".slider-button");
          const paginationDot = target.closest(".pagination-dot");
          const fullscreenButton = target.closest(".fullscreen-button");

          if (!button && !paginationDot && !fullscreenButton) return;

          // Get associated card
          const card = button?.closest(".project-card") || paginationDot?.closest(".project-card") || fullscreenButton?.closest(".project-card");

          if (!card) return;

          // Handle different control clicks
          if (button) {
            e.preventDefault();
            e.stopPropagation();
            const direction = parseInt(button.dataset.direction || "0", 10);
            const sliderContainer = card.querySelector(".slider-container");
            if (sliderContainer && (direction === 1 || direction === -1)) {
              navigateSlider(sliderContainer, direction);
            }
          } else if (paginationDot) {
            e.preventDefault();
            e.stopPropagation();
            const index = parseInt(paginationDot.dataset.index || "0", 10);
            const sliderContainer = card.querySelector(".slider-container");
            if (sliderContainer) {
              goToSlide(sliderContainer, index);
            }
          } else if (fullscreenButton) {
            e.preventDefault();
            e.stopPropagation();
            const currentIndex = getCurrentSlideIndex(card);
            const currentImage = card.querySelectorAll(".slider-slide img")[currentIndex];
            if (currentImage) {
              openLightbox(currentImage);
            }
          }
        },
        { passive: false }
      );
    }

    // --- Optimized Touch Handling for Mobile ---
    sliders.forEach((slider) => {
      // Initialize touch state object
      touchStates.set(slider, {
        startX: 0,
        startY: 0,
        startTime: 0,
        isSwiping: false,
        isScrolling: null,
      });

      // More efficient event handling
      slider.addEventListener("touchstart", handleTouchStart, { passive: true });
      slider.addEventListener("touchmove", handleTouchMove, { passive: false });
      slider.addEventListener("touchend", handleTouchEnd, { passive: true });

      // Set up scroll detection with optimized performance
      setupSliderScrollDetection(slider);
    });

    // Touch event handlers
    function handleTouchStart(e) {
      if (isLightboxOpen) return;

      const state = touchStates.get(this);
      if (!state) return;

      const touch = e.touches[0];
      state.startX = touch.clientX;
      state.startY = touch.clientY;
      state.startTime = Date.now();
      state.isSwiping = false;
      state.isScrolling = null; // null means undetermined
    }

    function handleTouchMove(e) {
      if (isLightboxOpen) return;

      const state = touchStates.get(this);
      if (!state) return;

      if (state.isScrolling === null) {
        const touch = e.touches[0];
        const diffX = touch.clientX - state.startX;
        const diffY = touch.clientY - state.startY;

        // Determine if the user is scrolling vertically or swiping horizontally
        // Use a higher threshold for vertical to allow small accidental movements
        state.isScrolling = Math.abs(diffY) > Math.abs(diffX) * 1.2;
      }

      // If horizontal swipe is detected, prevent default to avoid page scroll
      if (state.isScrolling === false) {
        e.preventDefault();
        state.isSwiping = true;
      }
    }

    function handleTouchEnd(e) {
      if (isLightboxOpen) return;

      const state = touchStates.get(this);
      if (!state || !state.isSwiping) return;

      const touch = e.changedTouches[0];
      const diffX = touch.clientX - state.startX;
      const elapsedTime = Date.now() - state.startTime;

      // Only navigate if the swipe was significant and fast enough
      if (Math.abs(diffX) > 40 && elapsedTime < 300) {
        navigateSlider(this, diffX < 0 ? 1 : -1);
      }

      // Reset state for next touch
      state.isSwiping = false;
      state.isScrolling = null;
    }

    // Navigation functions
    function navigateSlider(container, direction) {
      if (!container) return;

      const slideWidth = container.clientWidth;
      const totalSlides = parseInt(container.dataset.totalSlides || "1");
      const currentIndex = Math.round(container.scrollLeft / slideWidth);
      let targetIndex = currentIndex + direction;

      // Ensure target index is within bounds
      if (targetIndex < 0) targetIndex = 0;
      if (targetIndex >= totalSlides) targetIndex = totalSlides - 1;

      goToSlide(container, targetIndex);
    }

    function goToSlide(container, index) {
      if (!container) return;

      // Use a variable to track if this is the first time we are calling updateSliderIndicators
      const slideWidth = container.clientWidth;

      // Ensure smooth scrolling only happens when really changing slides
      const currentSlide = Math.round(container.scrollLeft / slideWidth);

      if (currentSlide !== index) {
        container.scrollTo({
          left: slideWidth * index,
          behavior: "smooth",
        });

        // Immediately update indicators for better UX
        updateSliderIndicators(container, index);
      }
    }

    function getCurrentSlideIndex(card) {
      const container = card.querySelector(".slider-container");
      return container ? Math.round(container.scrollLeft / container.clientWidth) : 0;
    }

    // Optimized scroll detection to reduce jank
    function setupSliderScrollDetection(slider) {
      // Use requestAnimationFrame for better performance and throttling
      let isScrolling = false;
      let lastScrollPos = slider.scrollLeft;

      slider.addEventListener(
        "scroll",
        () => {
          if (!isScrolling) {
            isScrolling = true;

            requestAnimationFrame(() => {
              // Only update if the scroll position has changed significantly
              if (Math.abs(slider.scrollLeft - lastScrollPos) > 10) {
                updateSliderIndicators(slider);
                lastScrollPos = slider.scrollLeft;
              }
              isScrolling = false;
            });
          }
        },
        { passive: true }
      );

      // Initial update
      updateSliderIndicators(slider);
    }

    // Optimize indicator updates
    function updateSliderIndicators(container, forcedIndex = null) {
      const card = container.closest(".project-card");
      if (!card) return;

      // Use a uniform calculation for active index to avoid jitter
      const slideWidth = container.clientWidth;
      const activeIndex = forcedIndex !== null ? forcedIndex : Math.round(container.scrollLeft / slideWidth);

      // Update pagination dots (use cached property for performance)
      const dots = card.querySelectorAll(".pagination-dot");
      for (let i = 0; i < dots.length; i++) {
        dots[i].classList.toggle("active", i === activeIndex);
      }

      // Update counter
      const currentSlideEl = card.querySelector(".current-slide");
      if (currentSlideEl) {
        currentSlideEl.textContent = `${activeIndex + 1}`;
      }

      // Optimize slide updating by only toggling classes on what's needed
      const slides = container.querySelectorAll(".slider-slide");
      for (let i = 0; i < slides.length; i++) {
        slides[i].classList.toggle("active", i === activeIndex);
      }
    }

    // Improved lightbox with proper focus and scroll management
    function openLightbox(img) {
      // Save the current scroll position and overflow state
      originalScrollPos = window.scrollY;
      originalOverflow = document.body.style.overflow || "";
      isLightboxOpen = true;

      const lightbox = document.createElement("div");
      lightbox.className = "image-lightbox";
      lightbox.setAttribute("role", "dialog");
      lightbox.setAttribute("aria-modal", "true");

      const content = document.createElement("div");
      content.className = "lightbox-content";

      // Clone image with properties preserved
      const imgClone = document.createElement("img");
      imgClone.src = img.src;
      imgClone.alt = img.alt;
      imgClone.loading = "eager"; // Force immediate loading for lightbox

      const closeBtn = document.createElement("button");
      closeBtn.className = "lightbox-close";
      closeBtn.innerHTML = "&times;";
      closeBtn.setAttribute("aria-label", "Close fullscreen view");

      // Assemble lightbox
      content.appendChild(imgClone);
      content.appendChild(closeBtn);
      lightbox.appendChild(content);
      document.body.appendChild(lightbox);

      // Add blur effect to non-lightbox content (improves focus)
      document.getElementById("main-content")?.classList.add("lightbox-blur");

      // Prevent background scrolling
      document.body.style.overflow = "hidden";
      document.body.style.position = "fixed";
      document.body.style.width = "100%";
      document.body.style.top = `-${originalScrollPos}px`;

      // Give keyboard focus to close button
      setTimeout(() => closeBtn.focus(), 100);

      // Set up close handlers with scroll position restoration
      function closeLightbox(e) {
        if (e) e.stopPropagation();

        // Fade out
        lightbox.classList.add("closing");
        document.getElementById("main-content")?.classList.remove("lightbox-blur");

        // Wait for animation
        setTimeout(() => {
          // Restore body state and scroll position
          document.body.style.overflow = originalOverflow;
          document.body.style.position = "";
          document.body.style.width = "";
          document.body.style.top = "";
          window.scrollTo(0, originalScrollPos);

          // Remove the lightbox
          document.body.removeChild(lightbox);
          isLightboxOpen = false;
        }, 300);
      }

      // Set up event handlers
      closeBtn.addEventListener("click", closeLightbox, { once: true });
      lightbox.addEventListener("click", (e) => {
        if (e.target === lightbox) closeLightbox(e);
      });

      // Keyboard support (ESC key)
      const handleKeyDown = (e) => {
        if (e.key === "Escape") {
          closeLightbox(e);
          document.removeEventListener("keydown", handleKeyDown);
        }
      };
      document.addEventListener("keydown", handleKeyDown);
    }

    // Create and add lightbox styles if they don't exist
    if (!document.getElementById("lightbox-styles")) {
      const style = document.createElement("style");
      style.id = "lightbox-styles";
      style.textContent = `
        .image-lightbox {
          position: fixed;
          top: 0;
          left: 0;
          width: 100%;
          height: 100%;
          background: rgba(0, 0, 0, 0.92);
          display: flex;
          align-items: center;
          justify-content: center;
          z-index: 9999;
          cursor: pointer;
          transition: opacity 0.3s ease;
        }
        
        .image-lightbox.closing {
          opacity: 0;
        }
        
        .lightbox-content {
          position: relative;
          max-width: 90%;
          max-height: 90%;
        }
        
        .lightbox-content img {
          max-width: 100%;
          max-height: 85vh;
          object-fit: contain;
          animation: lightbox-zoom-in 0.4s ease-out forwards;
        }
        
        .lightbox-close {
          position: absolute;
          top: -2.5rem;
          right: -2.5rem;
          background: transparent;
          border: none;
          color: white;
          font-size: 2.5rem;
          cursor: pointer;
          padding: 0.5rem;
          line-height: 0.8;
          opacity: 0.8;
          transition: transform 0.2s ease, opacity 0.2s ease;
        }
        
        .lightbox-close:hover,
        .lightbox-close:focus {
          opacity: 1;
          transform: scale(1.1);
          outline: none;
        }
        
        .lightbox-blur {
          filter: blur(3px);
        }
        
        @media (max-width: 768px) {
          .lightbox-close {
            top: -2rem;
            right: -1rem;
            font-size: 2rem;
            background: rgba(0,0,0,0.5);
            border-radius: 50%;
            width: 40px;
            height: 40px;
            display: flex;
            align-items: center;
            justify-content: center;
          }
          
          .lightbox-content img {
            max-height: 80vh;
          }
        }
      `;
      document.head.appendChild(style);
    }
  });
</script>
