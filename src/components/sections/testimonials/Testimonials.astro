---
import "./testimonials-carousel.css";

const testimonials = [
  {
    id: 1,
    content: "Ehsan delivered our e-commerce platform with exceptional attention to detail. The site's performance metrics improved by 35% and our conversion rate jumped significantly. His expertise in modern web development was exactly what we needed.",
    name: "Sarah Johnson",
    role: "CTO, TechRetail",
    image: "https://images.unsplash.com/photo-1494790108377-be9c29b29330?ixlib=rb-4.0.3&ixid=M3wxMjA3fDB8MHxwaG90by1wYWdlfHx8fGVufDB8fHx8fA%3D%3D&auto=format&fit=crop&w=150&q=80",
  },
  {
    id: 2,
    content: "Working with Ehsan was a game-changer for our startup. He built our entire web application from scratch, implementing complex features like real-time data visualization and authentication that worked flawlessly. His problem-solving skills saved us countless hours.",
    name: "Michael Chen",
    role: "Founder, DataSync",
    image: "https://images.unsplash.com/photo-1507003211169-0a1dd7228f2d?ixlib=rb-4.0.3&ixid=M3wxMjA3fDB8MHxwaG90by1wYWdlfHx8fGVufDB8fHx8fA%3D%3D&auto=format&fit=crop&w=150&q=80",
  },
  {
    id: 3,
    content: "I was impressed by Ehsan's ability to translate our design concepts into functional, responsive websites. His knowledge of modern CSS and animation techniques brought our brand to life online, and the custom CMS he built makes updates incredibly easy.",
    name: "Priya Patel",
    role: "Marketing Director, CreativeWorks",
    image: "https://images.unsplash.com/photo-1573496359142-b8d87734a5a2?ixlib=rb-4.0.3&ixid=M3wxMjA3fDB8MHxwaG90by1wYWdlfHx8fGVufDB8fHx8fA%3D%3D&auto=format&fit=crop&w=150&q=80",
  },
];
---

<section class="testimonial-section" id="testimonials" aria-labelledby="testimonials-heading">
  <!-- Heading Elements -->
  <div class="px-4 text-center mb-12 md:mb-16">
    <h2 id="testimonials-heading" class="text-4xl md:text-5xl font-doto font-bold mb-4">
      <span class="text-accent-title">Client</span>{" "}
      Testimonials
    </h2>
    <div class="w-24 h-1 bg-gradient-to-r from-[oklch(var(--accent-500))] to-[oklch(var(--accent-900))] mx-auto rounded-full"></div>
    <p class="text-foreground-muted max-w-2xl mx-auto mt-6 text-lg">Don't just take my word for it - here's what clients have to say about working with me.</p>
  </div>

  <!-- Main carousel container with proper ARIA role -->
  <div class="testimonial-carousel-container" role="region" aria-roledescription="carousel" aria-label="Client testimonials carousel">
    <!-- Navigation Controls -->
    <div class="testimonial-controls">
      <button class="testimonial-btn-base testimonial-prev" aria-label="Previous testimonial" type="button">
        <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" class="w-6 h-6">
          <path stroke-linecap="round" stroke-linejoin="round" d="M15.75 19.5L8.25 12l7.5-7.5"></path>
        </svg>
      </button>

      <button class="testimonial-btn-base testimonial-next" aria-label="Next testimonial" type="button">
        <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" class="w-6 h-6">
          <path stroke-linecap="round" stroke-linejoin="round" d="M8.25 4.5l7.5 7.5-7.5 7.5"></path>
        </svg>
      </button>
    </div>

    <!-- Viewport for slides with live region for accessibility -->
    <div class="testimonial-carousel-viewport" aria-live="polite">
      {
        testimonials.map((testimonial, index) => (
          <div class={`testimonial-slide animate-when-visible ${index === 0 ? "slide-visible" : ""}`} data-index={index} role="tabpanel" aria-roledescription="slide" aria-label={`Testimonial from ${testimonial.name}`} aria-hidden={index !== 0}>
            <div class="testimonial-card">
              <div class="testimonial-accent" aria-hidden="true" />
              <svg class="quote-icon" fill="currentColor" viewBox="0 0 24 24" aria-hidden="true">
                <path d="M14.017 21v-7.391c0-5.704 3.731-9.57 8.983-10.609l.995 2.151c-2.432.917-3.995 3.638-3.995 5.849h4v10h-9.983zm-14.017 0v-7.391c0-5.704 3.748-9.57 9-10.609l.996 2.151c-2.433.917-3.996 3.638-3.996 5.849h3.983v10h-9.983z" />
              </svg>

              <p class="testimonial-content">{testimonial.content}</p>

              <div class="testimonial-author-container">
                <div class="testimonial-author-avatar">
                  <img src={testimonial.image} class="testimonial-author-image" alt={`${testimonial.name}, ${testimonial.role}`} loading="lazy" />
                </div>
                <div class="testimonial-author-details">
                  <h4 class="testimonial-author-name">{testimonial.name}</h4>
                  <p class="testimonial-author-role">{testimonial.role}</p>
                </div>
              </div>
            </div>
          </div>
        ))
      }
    </div>

    <!-- Pagination dots inside carousel container -->
    <div class="testimonial-pagination" role="tablist">
      {testimonials.map((testimonial, index) => <button class={`testimonial-dot ${index === 0 ? "testimonial-dot-active" : "testimonial-dot-inactive"}`} data-index={index} aria-label={`View testimonial from ${testimonial.name}`} role="tab" aria-selected={index === 0} type="button" />)}
    </div>
  </div>
</section>

<script>
  document.addEventListener("DOMContentLoaded", setupCarousel);
  document.addEventListener("astro:page-load", setupCarousel);

  function setupCarousel(): void {
    const slides = document.querySelectorAll<HTMLElement>(".testimonial-slide");
    const dots = document.querySelectorAll<HTMLElement>(".testimonial-dot");
    const prevBtn = document.querySelector<HTMLButtonElement>(".testimonial-prev");
    const nextBtn = document.querySelector<HTMLButtonElement>(".testimonial-next");
    const carouselContainer = document.querySelector<HTMLElement>(".testimonial-carousel-container");
    const testimonialSection = document.querySelector<HTMLElement>(".testimonial-section");

    const autoplayDelay = 5000; // 5 seconds
    const autoplayDelayAfterInterruption = 10000; // 10 seconds

    let currentIndex = 0;
    let interval: number;
    let isAnimating = false;
    let startX = 0;
    const swipeThreshold = 50;
    let isInViewport = false;

    // Mouse drag variables
    let isDragging = false;
    let mouseStartX = 0;

    // Setup Intersection Observer to detect when carousel is in viewport
    const observer = new IntersectionObserver(
      (entries) => {
        entries.forEach((entry) => {
          isInViewport = entry.isIntersecting;

          if (isInViewport) {
            startAutoplay();
          } else {
            stopAutoplay();
          }
        });
      },
      { threshold: 0.1 }
    );

    // Start observing the carousel section
    if (testimonialSection) {
      observer.observe(testimonialSection);
    }

    // Touch handling
    carouselContainer?.addEventListener("touchstart", (e: TouchEvent) => {
      startX = e.touches[0].clientX;
      stopAutoplay();
    });

    carouselContainer?.addEventListener("touchend", (e: TouchEvent) => {
      const endX = e.changedTouches[0].clientX;
      const diff = endX - startX;
      if (Math.abs(diff) > swipeThreshold) {
        if (diff < 0) {
          nextTestimonial(); // swipe left
        } else {
          prevTestimonial(); // swipe right
        }
      }

      if (isInViewport) {
        setTimeout(startAutoplay, autoplayDelayAfterInterruption);
      }
    });

    // Mouse drag handling
    carouselContainer?.addEventListener("mousedown", (e: MouseEvent) => {
      isDragging = true;
      mouseStartX = e.clientX;
      carouselContainer.style.cursor = "grabbing";
      stopAutoplay();

      // Prevent default to avoid text selection during drag
      e.preventDefault();
    });

    window.addEventListener("mousemove", (e: MouseEvent) => {
      if (!isDragging) return;
      e.preventDefault();
    });

    window.addEventListener("mouseup", (e: MouseEvent) => {
      if (!isDragging) return;

      const endX = e.clientX;
      const diff = endX - mouseStartX;

      if (Math.abs(diff) > swipeThreshold) {
        if (diff < 0) {
          nextTestimonial(); // drag left
        } else {
          prevTestimonial(); // drag right
        }
      }

      isDragging = false;
      carouselContainer!.style.cursor = "grab";

      if (isInViewport) {
        setTimeout(startAutoplay, autoplayDelayAfterInterruption);
      }
    });

    // Add mouseleave to handle the case when the mouse leaves the window
    window.addEventListener("mouseleave", () => {
      if (isDragging) {
        isDragging = false;
        carouselContainer!.style.cursor = "grab";

        if (isInViewport) {
          setTimeout(startAutoplay, autoplayDelayAfterInterruption);
        }
      }
    });

    function showTestimonial(index: number, reverseAnimation = false): void {
      if (isAnimating || index === currentIndex) return;
      isAnimating = true;

      // Get current and next elements
      const currentSlide = slides[currentIndex];
      const nextSlide = slides[index];

      // Update dots
      dots.forEach((dot, i) => {
        if (i === index) {
          dot.classList.add("testimonial-dot-active");
          dot.classList.remove("testimonial-dot-inactive");
        } else {
          dot.classList.remove("testimonial-dot-active");
          dot.classList.add("testimonial-dot-inactive");
        }
      });

      // Hide current slide
      const animationClass = reverseAnimation ? "entering" : "leaving";
      currentSlide.classList.add(animationClass);

      // Wait for animation to finish
      setTimeout(() => {
        currentSlide.classList.remove(animationClass, "slide-visible");
        currentSlide.style.display = "none";

        // Show next slide
        nextSlide.style.display = "block";

        // Force a reflow to make sure display:block is applied before adding animation class
        void nextSlide.offsetHeight;

        nextSlide.classList.add("slide-visible");

        setTimeout(() => {
          isAnimating = false;
        }, 500);
      }, 500);

      currentIndex = index;
    }

    function nextTestimonial(): void {
      const newIndex = (currentIndex + 1) % slides.length;
      showTestimonial(newIndex);
    }

    function prevTestimonial(): void {
      const newIndex = (currentIndex - 1 + slides.length) % slides.length;
      showTestimonial(newIndex, true);
    }

    function startAutoplay(): void {
      clearInterval(interval);
      interval = window.setInterval(nextTestimonial, autoplayDelay);
    }

    function stopAutoplay(): void {
      clearInterval(interval);
    }

    // Initialize slides properly
    slides.forEach((slide, index) => {
      if (index === 0) {
        slide.style.display = "block";
        slide.classList.add("slide-visible");
      } else {
        slide.style.display = "none";
        slide.classList.remove("slide-visible");
      }
    });

    // Set default cursor style for carousel container
    if (carouselContainer) {
      carouselContainer.style.cursor = "grab";
    }

    // Set up event listeners
    dots.forEach((dot, index) => {
      dot.addEventListener("click", () => {
        stopAutoplay();
        showTestimonial(index);

        if (isInViewport) {
          setTimeout(startAutoplay, autoplayDelayAfterInterruption);
        }
      });
    });

    prevBtn?.addEventListener("click", () => {
      stopAutoplay();
      prevTestimonial();

      if (isInViewport) {
        setTimeout(startAutoplay, autoplayDelayAfterInterruption);
      }
    });

    nextBtn?.addEventListener("click", () => {
      stopAutoplay();
      nextTestimonial();

      if (isInViewport) {
        setTimeout(startAutoplay, autoplayDelayAfterInterruption);
      }
    });

    // Hover control
    carouselContainer?.addEventListener("mouseenter", stopAutoplay);
    carouselContainer?.addEventListener("mouseleave", () => {
      // Only start autoplay if not currently dragging and in viewport
      if (!isDragging && isInViewport) {
        setTimeout(startAutoplay, autoplayDelay);
      }
    });

    // Cleanup function to disconnect observer when needed
    document.addEventListener("astro:before-swap", () => {
      observer.disconnect();
      stopAutoplay();
    });

    if (isInViewport) {
      startAutoplay();
    }
  }
</script>
