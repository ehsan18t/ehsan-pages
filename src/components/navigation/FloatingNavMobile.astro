---
import { Icon } from "astro-icon/components";
import info from "@/data";

const navItems = info.navItems;
---

<nav id="floating-nav-mobile" class="floating-nav-mobile" role="navigation" aria-label="Primary">
  <div class="nav-container">
    <div class="active-indicator" aria-hidden="true"></div>
    {
      navItems.map((item, index) => (
        <a href={item.href} class={`nav-item ${index === 0 ? "active" : ""}`} data-section={item.section} {...(item.offset !== undefined ? { "data-offset": item.offset } : {})} aria-label={item.label} aria-current={index === 0 ? "page" : undefined}>
          <span class="icon-wrapper">
            <Icon name={item.icon} class="nav-icon" />
          </span>
          <span class="nav-label">{item.label}</span>
        </a>
      ))
    }
  </div>
</nav>

<style>
  @reference "@/assets/styles/global.css";

  .floating-nav-mobile {
    display: none;
  }

  @media (max-width: 767px) {
    .floating-nav-mobile {
      @apply pointer-events-none fixed inset-x-4 bottom-4 z-50 block opacity-0;
      transition: opacity 0.4s cubic-bezier(0.4, 0.8, 0.2, 1);
    }

    .nav-container {
      position: relative;
      @apply flex w-full items-stretch justify-between gap-1 rounded-3xl p-2;
      background:
        linear-gradient(140deg, rgba(255, 255, 255, 0.08), rgba(255, 255, 255, 0) 60%) border-box,
        rgba(10, 25, 45, 0.55);
      border: 1px solid rgba(255, 255, 255, 0.12);
      backdrop-filter: blur(18px) saturate(140%);
      -webkit-backdrop-filter: blur(18px) saturate(140%);
      box-shadow:
        0 4px 10px -2px rgba(0, 0, 0, 0.4),
        0 8px 28px -6px rgba(0, 0, 0, 0.45);
      pointer-events: auto;
      overflow: hidden;
      isolation: isolate;
    }

    .active-indicator {
      position: absolute;
      top: 6px;
      left: 0;
      height: calc(100% - 12px);
      width: 0; /* set in JS */
      box-sizing: border-box; /* critical fix: include border in width */
      background: linear-gradient(145deg, oklch(var(--accent-bg) / 0.55), oklch(var(--accent-bg) / 0.25));
      border: 1px solid oklch(var(--accent-bg) / 0.5);
      box-shadow:
        inset 0 0 0 1px oklch(var(--accent-bg) / 0.35),
        0 4px 10px -2px oklch(var(--accent-bg) / 0.55);
      border-radius: 18px;
      transform: translateX(0);
      transition:
        transform 0.45s cubic-bezier(0.55, 0.2, 0.15, 1),
        width 0.28s cubic-bezier(0.55, 0.2, 0.15, 1);
      will-change: transform, width;
      z-index: 0;
      pointer-events: none;
    }

    .nav-item {
      position: relative;
      @apply flex flex-col items-center justify-center gap-1 px-3 py-2 text-[11px] font-medium;
      min-width: 60px;
      text-decoration: none;
      color: rgb(var(--foreground-muted));
      border-radius: 16px;
      line-height: 1;
      -webkit-tap-highlight-color: transparent;
      transition: color 0.3s;
      z-index: 1;
    }

    .nav-item:focus-visible {
      outline: 2px solid oklch(var(--accent-bg));
      outline-offset: 2px;
    }

    .icon-wrapper {
      @apply flex items-center justify-center;
      width: 26px;
      height: 26px;
      border-radius: 10px;
      transition:
        background 0.3s,
        transform 0.3s;
    }

    .nav-icon {
      @apply h-5 w-5;
      transition:
        transform 0.35s,
        filter 0.35s;
    }

    .nav-item.active .icon-wrapper,
    .nav-item:hover .icon-wrapper {
      background: oklch(var(--accent-bg) / 0.18);
    }

    .nav-item.active .nav-icon {
      transform: scale(1.07);
      filter: drop-shadow(0 2px 4px oklch(var(--accent-bg) / 0.55));
    }

    .nav-label {
      letter-spacing: 0.25px;
      opacity: 0.85;
      transition: opacity 0.3s;
    }
    .nav-item:not(.active) .nav-label {
      opacity: 0.65;
    }

    .nav-item.active,
    .nav-item:hover {
      color: oklch(var(--accent-text));
    }

    .nav-item:active .icon-wrapper {
      transform: scale(0.92);
    }

    @media (prefers-reduced-motion: reduce) {
      .active-indicator,
      .nav-icon,
      .icon-wrapper,
      .floating-nav-mobile {
        transition: none !important;
      }
    }

    body:has(#hero-loader) .floating-nav-mobile {
      opacity: 0 !important;
      pointer-events: none;
    }
  }
</style>

<script>
  document.addEventListener("DOMContentLoaded", () => {
    const nav = document.getElementById("floating-nav-mobile");
    if (!nav) return;

    const links = Array.from(nav.querySelectorAll(".nav-item"));
    const indicator: any = nav.querySelector(".active-indicator");
    let frame: any = null;

    function getScrollContainer(el: any) {
      let node = el?.parentElement;
      while (node) {
        const style = getComputedStyle(node);
        if (/(auto|scroll)/.test(style.overflowY) && node.scrollHeight > node.clientHeight) return node;
        node = node.parentElement;
      }
      return document.scrollingElement || document.documentElement;
    }

    function updateIndicator(el: any) {
      if (!indicator || !el) return;
      // Use offset metrics (padding & gap already accounted for)
      const width = el.offsetWidth;
      const left = el.offsetLeft;
      indicator.style.width = width + "px";
      indicator.style.transform = `translateX(${left}px)`;
    }

    function setActive(id: string) {
      let activeEl: any = null;
      links.forEach((a) => {
        const match = a.getAttribute("href")?.slice(1) === id;
        a.classList.toggle("active", match);
        if (match) {
          a.setAttribute("aria-current", "page");
          activeEl = a;
        } else {
          a.removeAttribute("aria-current");
        }
      });
      if (activeEl) {
        cancelAnimationFrame(frame);
        frame = requestAnimationFrame(() => updateIndicator(activeEl));
      }
    }

    // Smooth scroll with optional offset
    links.forEach((link) => {
      link.addEventListener("click", (e) => {
        e.preventDefault();
        const id = link.getAttribute("href")?.slice(1);
        const target = id ? document.getElementById(id) : null;
        if (!target) return;

        const offsetAttr = link.getAttribute("data-offset");
        const offset = offsetAttr !== null ? Number(offsetAttr) : NaN;
        const container = getScrollContainer(target);

        if (!isNaN(offset)) {
          const containerRect = container.getBoundingClientRect();
          const targetRect = target.getBoundingClientRect();
          const currentScrollTop = container.scrollTop;
          const relativeTop = targetRect.top - containerRect.top;
          container.scrollTo({ top: currentScrollTop + relativeTop - offset, behavior: "smooth" });
        } else {
          target.scrollIntoView({ behavior: "smooth", block: "start" });
        }
      });
    });

    const observedSections = links.map((l) => document.getElementById(l.getAttribute("href")?.substring(1) || "")).filter(Boolean);

    const observer = new IntersectionObserver(
      (entries) => {
        entries.forEach((entry) => {
          if (entry.isIntersecting) setActive(entry.target.id);
        });
      },
      { root: null, rootMargin: "-25% 0px -55% 0px", threshold: 0 },
    );

    observedSections.forEach((sec: any) => observer.observe(sec));

    // Initial reveal + indicator sync
    requestAnimationFrame(() => {
      nav.style.opacity = "1";
      nav.style.pointerEvents = "auto";
      setTimeout(() => {
        const active = links.find((a) => a.classList.contains("active")) || links[0];
        updateIndicator(active);
      }, 40);
    });

    function handleResize() {
      const active = links.find((a) => a.classList.contains("active"));
      if (active) updateIndicator(active);
    }
    window.addEventListener("resize", handleResize);
    window.addEventListener("orientationchange", handleResize);
  });
</script>
